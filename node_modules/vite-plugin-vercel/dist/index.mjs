var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};

// src/index.ts
import fs3 from "fs/promises";

// src/utils.ts
import { normalizePath } from "vite";
import path from "path";
import fs from "fs/promises";
function getRoot(config) {
  return normalizePath(config.root || process.cwd());
}
function getOutDir(config, force) {
  const p = normalizePath(config.build.outDir);
  if (!force)
    return p;
  return path.join(path.dirname(p), force);
}
function getOutput(config, suffix) {
  var _a, _b;
  return path.join(((_a = config.vercel) == null ? void 0 : _a.outDir) ? "" : getRoot(config), ((_b = config.vercel) == null ? void 0 : _b.outDir) ?? ".output", suffix ?? "");
}
function pathRelativeToApi(filePath, config) {
  const root = getRoot(config);
  return normalizePath(path.relative(path.join(root, "api"), filePath));
}
async function copyDir(src, dest) {
  await fs.mkdir(dest, { recursive: true });
  const entries = await fs.readdir(src, { withFileTypes: true });
  for (const entry of entries) {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);
    entry.isDirectory() ? await copyDir(srcPath, destPath) : await fs.copyFile(srcPath, destPath);
  }
}

// src/manifests.ts
import path2 from "path";

// src/assert.ts
import { newError } from "@brillout/libassert";
var libName = "vite-plugin-vercel";
function assert(condition, errorMessage) {
  if (condition) {
    return;
  }
  const err = newError(`[${libName}][Wrong Usage] ${errorMessage}`, 2);
  throw err;
}

// src/schemas/manifests/routes.ts
import { z } from "zod";
var routesManifestRedirectSchema = z.object({
  source: z.string(),
  destination: z.string(),
  statusCode: z.number().refine((n) => [301, 302, 307, 308].includes(n)),
  regex: z.string()
}).strict();
var routesManifestHeaderSchema = z.object({
  source: z.string(),
  headers: z.array(z.object({
    key: z.string(),
    value: z.string()
  }).strict()),
  regex: z.string()
}).strict();
var routesManifestRewriteSchema = z.object({
  source: z.string(),
  has: z.array(z.object({
    key: z.string(),
    value: z.string(),
    type: z.enum(["header", "cookie", "host", "query"])
  }).strict()).optional(),
  destination: z.string(),
  regex: z.string()
}).strict();
var routesManifestDynamicRouteSchema = z.object({
  page: z.string(),
  regex: z.string(),
  routeKeys: z.record(z.string()).optional(),
  namedRegex: z.string().optional()
}).strict();
var routesManifestSchema = z.object({
  version: z.literal(3),
  basePath: z.string().regex(/^\/.*/),
  pages404: z.boolean(),
  redirects: z.array(routesManifestRedirectSchema).optional(),
  headers: z.array(routesManifestHeaderSchema).optional(),
  rewrites: z.array(routesManifestRewriteSchema).optional(),
  dynamicRoutes: z.array(routesManifestDynamicRouteSchema).optional()
}).strict();

// src/schemas/manifests/functions.ts
import { z as z2 } from "zod";
var functionsManifestSchemaPage = z2.object({
  runtime: z2.string().optional(),
  handler: z2.string().optional(),
  regions: z2.array(z2.string()).optional(),
  maxDuration: z2.number().min(1).max(900).optional(),
  memory: z2.number().min(128).max(3008).optional()
}).strict();
var functionsManifestSchemaPageWeb = functionsManifestSchemaPage.omit({
  runtime: true
}).merge(z2.object({
  runtime: z2.literal("web"),
  env: z2.array(z2.string()),
  files: z2.array(z2.string()),
  name: z2.string(),
  page: z2.string(),
  regexp: z2.string(),
  sortingIndex: z2.number()
}).strict());
var functionsManifestSchema = z2.object({
  version: z2.literal(1),
  pages: z2.object({
    "_middleware.js": functionsManifestSchemaPageWeb.optional()
  }).and(z2.record(z2.intersection(functionsManifestSchemaPageWeb.omit({
    runtime: true
  }).partial(), functionsManifestSchemaPage)))
});

// src/schemas/manifests/prerender.ts
import { z as z3 } from "zod";
var prerenderManifestSchemaRoute = z3.object({
  initialRevalidateSeconds: z3.number(),
  srcRoute: z3.string(),
  dataRoute: z3.string()
}).strict();
var prerenderManifestSchemaDynamicRoute = z3.object({
  routeRegex: z3.string(),
  fallback: z3.string().or(z3.null()),
  dataRoute: z3.string(),
  dataRouteRegex: z3.string()
}).strict();
var prerenderManifestSchema = z3.object({
  version: z3.literal(3),
  routes: z3.record(prerenderManifestSchemaRoute),
  dynamicRoutes: z3.record(prerenderManifestSchemaDynamicRoute),
  preview: z3.object({
    previewModeId: z3.string().or(z3.null())
  }).strict()
}).strict();

// src/manifests.ts
function getPrerenderManifest(resolvedConfig, isrPages) {
  var _a, _b;
  const prerenderManifestDefault = (_a = resolvedConfig.vercel) == null ? void 0 : _a.prerenderManifest;
  const routes = Object.entries((isrPages == null ? void 0 : isrPages.routes) ?? {}).reduce((acc, [key, val]) => {
    var _a2, _b2, _c, _d, _e, _f, _g;
    const srcRoute = (val == null ? void 0 : val.srcRoute) ?? ((_b2 = (_a2 = prerenderManifestDefault == null ? void 0 : prerenderManifestDefault.routes) == null ? void 0 : _a2[key]) == null ? void 0 : _b2.srcRoute);
    assert(typeof srcRoute === "string", `\`[prerender-manifest] { srcRoute }\` is required for route ${key}`);
    acc[key === "/" ? "/index" : key] = {
      initialRevalidateSeconds: (val == null ? void 0 : val.initialRevalidateSeconds) ?? ((_d = (_c = prerenderManifestDefault == null ? void 0 : prerenderManifestDefault.routes) == null ? void 0 : _c[key]) == null ? void 0 : _d.initialRevalidateSeconds) ?? ((_e = resolvedConfig.vercel) == null ? void 0 : _e.initialRevalidateSeconds) ?? 86400,
      srcRoute,
      dataRoute: (val == null ? void 0 : val.dataRoute) ?? ((_g = (_f = prerenderManifestDefault == null ? void 0 : prerenderManifestDefault.routes) == null ? void 0 : _f[key]) == null ? void 0 : _g.dataRoute) ?? ""
    };
    return acc;
  }, {});
  const dynamicRoutes = Object.entries((isrPages == null ? void 0 : isrPages.dynamicRoutes) ?? {}).reduce((acc, [key, val]) => {
    var _a2;
    const override = (_a2 = prerenderManifestDefault == null ? void 0 : prerenderManifestDefault.dynamicRoutes) == null ? void 0 : _a2[key];
    const routeRegex = (val == null ? void 0 : val.routeRegex) ?? (override == null ? void 0 : override.routeRegex);
    const fallback = (val == null ? void 0 : val.fallback) === null || typeof (val == null ? void 0 : val.fallback) === "string" ? val == null ? void 0 : val.fallback : (override == null ? void 0 : override.fallback) === null || typeof (override == null ? void 0 : override.fallback) === "string" ? override == null ? void 0 : override.fallback : null;
    assert(routeRegex, `\`[prerender-manifest] { routeRegex }\` is required for route ${key}`);
    acc[key] = {
      routeRegex,
      fallback,
      dataRoute: (val == null ? void 0 : val.dataRoute) ?? (override == null ? void 0 : override.dataRoute) ?? "",
      dataRouteRegex: (val == null ? void 0 : val.dataRouteRegex) ?? (override == null ? void 0 : override.dataRouteRegex) ?? ""
    };
    return acc;
  }, {});
  return prerenderManifestSchema.parse({
    version: 3,
    routes,
    dynamicRoutes,
    preview: {
      previewModeId: ((_b = prerenderManifestDefault == null ? void 0 : prerenderManifestDefault.preview) == null ? void 0 : _b.previewModeId) ?? null
    }
  });
}
function getPrerenderManifestDestination(resolvedConfig) {
  return path2.join(getOutput(resolvedConfig), "prerender-manifest.json");
}
function getRoutesManifest(resolvedConfig, ssr) {
  var _a;
  const routesManifest = (_a = resolvedConfig.vercel) == null ? void 0 : _a.routesManifest;
  const allRewrites = [
    ...(routesManifest == null ? void 0 : routesManifest.rewrites) ?? [],
    ...(ssr == null ? void 0 : ssr.rewrites) ?? []
  ];
  const allDynamicRoutes = [
    ...(routesManifest == null ? void 0 : routesManifest.dynamicRoutes) ?? [],
    ...(ssr == null ? void 0 : ssr.dynamicRoutes) ?? []
  ];
  const allHeaders = [
    ...(routesManifest == null ? void 0 : routesManifest.headers) ?? [],
    ...(ssr == null ? void 0 : ssr.headers) ?? []
  ];
  return routesManifestSchema.parse({
    version: 3,
    basePath: (routesManifest == null ? void 0 : routesManifest.basePath) ?? "/",
    pages404: (routesManifest == null ? void 0 : routesManifest.pages404) ?? true,
    dynamicRoutes: allDynamicRoutes.length > 0 ? allDynamicRoutes : void 0,
    rewrites: allRewrites.length > 0 ? allRewrites : void 0,
    redirects: routesManifest == null ? void 0 : routesManifest.redirects,
    headers: allHeaders.length > 0 ? allHeaders : void 0
  });
}
function getRoutesManifestDestination(resolvedConfig) {
  return path2.join(getOutput(resolvedConfig), "routes-manifest.json");
}
function getFunctionsManifest(pages) {
  return functionsManifestSchema.parse({
    version: 1,
    pages
  });
}
function getFunctionsManifestDestination(resolvedConfig) {
  return path2.join(getOutput(resolvedConfig), "functions-manifest.json");
}

// src/build.ts
import glob from "fast-glob";
import path3 from "path";
import { build } from "esbuild";
import fs2 from "fs/promises";
function getPagesEndpoints(resolvedConfig) {
  var _a;
  const apiEndpoints = (((_a = resolvedConfig.vercel) == null ? void 0 : _a.pagesEndpoints) ?? []).map((p) => path3.isAbsolute(p) ? p : path3.resolve(getRoot(resolvedConfig), p));
  return new Set(apiEndpoints);
}
function getApiEntries(resolvedConfig) {
  var _a;
  const pagesEndpoints = getPagesEndpoints(resolvedConfig);
  const apiEntries = glob.sync(`${getRoot(resolvedConfig)}/api/**/*.*([a-zA-Z0-9])`).filter((filepath) => !path3.basename(filepath).startsWith("_"));
  return apiEntries.reduce((entryPoints, filePath) => {
    const outFilePath = pathRelativeToApi(filePath, resolvedConfig);
    const parsed = path3.parse(outFilePath);
    const alsoPage = pagesEndpoints.has(filePath);
    const entry = {
      source: filePath,
      destination: [`api/${path3.join(parsed.dir, parsed.name)}`]
    };
    if (alsoPage) {
      entry.destination.push(`${path3.join(parsed.dir, parsed.name)}`);
    }
    entryPoints.push(entry);
    return entryPoints;
  }, ((_a = resolvedConfig.vercel) == null ? void 0 : _a.additionalEndpoints) ?? []);
}
var standardBuildOptions = {
  bundle: true,
  target: "es2020",
  format: "cjs",
  platform: "node",
  logLevel: "info",
  minify: true
};
async function buildFn(resolvedConfig, entry, buildOptions) {
  var _a, _b, _c, _d;
  if (!Array.isArray(entry.destination)) {
    entry.destination = [entry.destination];
  }
  assert(entry.destination.length > 0, `Endpoint ${typeof entry.source === "string" ? entry.source : "-"} does not have build destination`);
  const [firstDestination, ...remainingDestinations] = entry.destination;
  const pages = ((_b = (_a = resolvedConfig.vercel) == null ? void 0 : _a.functionsManifest) == null ? void 0 : _b.pages) ?? {};
  const fnManifests = {};
  const outfile = path3.join(getOutput(resolvedConfig, "server/pages"), firstDestination + ".js");
  const options = Object.assign({}, standardBuildOptions, { outfile });
  if (buildOptions) {
    Object.assign(options, buildOptions);
  }
  if (!options.stdin) {
    if (typeof entry.source === "string") {
      options.entryPoints = [entry.source];
    } else {
      assert(typeof entry.source === "object", `\`{ source }\` must be a string or an object`);
      assert(typeof entry.source.contents === "string", `\`{ contents }\` must be a string`);
      options.stdin = entry.source;
    }
  }
  await build(options);
  fnManifests[firstDestination + ".js"] = __spreadValues({
    maxDuration: (_c = resolvedConfig.vercel) == null ? void 0 : _c.defaultMaxDuration
  }, pages[firstDestination + ".js"]);
  for (const dest of remainingDestinations) {
    await fs2.mkdir(path3.join(getOutput(resolvedConfig, "server/pages"), path3.dirname(dest)), {
      recursive: true
    });
    await fs2.copyFile(outfile, path3.join(getOutput(resolvedConfig, "server/pages"), dest + ".js"));
    fnManifests[dest + ".js"] = __spreadValues({
      maxDuration: (_d = resolvedConfig.vercel) == null ? void 0 : _d.defaultMaxDuration
    }, pages[dest + ".js"] ?? pages[firstDestination + ".js"]);
  }
  return fnManifests;
}
async function buildApiEndpoints(resolvedConfig) {
  const entries = getApiEntries(resolvedConfig);
  const fnManifests = {};
  for (const entry of entries) {
    Object.assign(fnManifests, await buildFn(resolvedConfig, entry));
  }
  return fnManifests;
}

// src/prerender.ts
function execPrerender(resolvedConfig) {
  var _a;
  const prerender = (_a = resolvedConfig.vercel) == null ? void 0 : _a.prerender;
  if (prerender === false) {
    return;
  }
  return prerender == null ? void 0 : prerender(resolvedConfig);
}

// src/index.ts
function vercelPlugin() {
  let resolvedConfig;
  return {
    apply: "build",
    name: "vite-plugin-vercel",
    enforce: "post",
    configResolved(config) {
      resolvedConfig = config;
    },
    async buildStart() {
      if (process.env.VERCEL_ENV === "production" && !process.env.ENABLE_FILE_SYSTEM_API) {
        throw new Error("Missing ENABLE_FILE_SYSTEM_API=1 to your environment variables in your project settings");
      }
      if (!resolvedConfig.build.ssr) {
        await cleanOutputDirectory(resolvedConfig);
      } else {
        await copyDistClientToOutputStatic(resolvedConfig);
      }
    },
    async writeBundle() {
      var _a;
      if (!((_a = resolvedConfig.build) == null ? void 0 : _a.ssr))
        return;
      const isrPages = await execPrerender(resolvedConfig);
      const fnManifests = await buildApiEndpoints(resolvedConfig);
      await generateFunctionsManifest(resolvedConfig, fnManifests);
      await generateRoutesManifest(resolvedConfig, isrPages == null ? void 0 : isrPages.ssr);
      await generatePrerenderManifest(resolvedConfig, isrPages == null ? void 0 : isrPages.isr);
    }
  };
}
async function copyDistClientToOutputStatic(resolvedConfig) {
  await copyDir(getOutDir(resolvedConfig, "client"), getOutput(resolvedConfig, "static"));
}
async function cleanOutputDirectory(resolvedConfig) {
  await fs3.rm(getOutput(resolvedConfig), {
    recursive: true,
    force: true
  });
}
async function generatePrerenderManifest(resolvedConfig, isrPages) {
  await fs3.writeFile(getPrerenderManifestDestination(resolvedConfig), JSON.stringify(getPrerenderManifest(resolvedConfig, isrPages), void 0, 2));
}
async function generateRoutesManifest(resolvedConfig, ssr) {
  await fs3.writeFile(getRoutesManifestDestination(resolvedConfig), JSON.stringify(getRoutesManifest(resolvedConfig, ssr), void 0, 2));
}
async function generateFunctionsManifest(resolvedConfig, fnManifests) {
  await fs3.writeFile(getFunctionsManifestDestination(resolvedConfig), JSON.stringify(getFunctionsManifest(fnManifests), void 0, 2));
}
function allPlugins() {
  return [vercelPlugin()];
}
export {
  allPlugins as default
};
