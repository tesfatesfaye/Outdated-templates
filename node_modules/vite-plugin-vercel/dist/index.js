var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => allPlugins
});
var import_promises3 = __toESM(require("fs/promises"));

// src/utils.ts
var import_vite = require("vite");
var import_path = __toESM(require("path"));
var import_promises = __toESM(require("fs/promises"));
function getRoot(config) {
  return (0, import_vite.normalizePath)(config.root || process.cwd());
}
function getOutDir(config, force) {
  const p = (0, import_vite.normalizePath)(config.build.outDir);
  if (!force)
    return p;
  return import_path.default.join(import_path.default.dirname(p), force);
}
function getOutput(config, suffix) {
  var _a, _b;
  return import_path.default.join(((_a = config.vercel) == null ? void 0 : _a.outDir) ? "" : getRoot(config), ((_b = config.vercel) == null ? void 0 : _b.outDir) ?? ".output", suffix ?? "");
}
function pathRelativeToApi(filePath, config) {
  const root = getRoot(config);
  return (0, import_vite.normalizePath)(import_path.default.relative(import_path.default.join(root, "api"), filePath));
}
async function copyDir(src, dest) {
  await import_promises.default.mkdir(dest, { recursive: true });
  const entries = await import_promises.default.readdir(src, { withFileTypes: true });
  for (const entry of entries) {
    const srcPath = import_path.default.join(src, entry.name);
    const destPath = import_path.default.join(dest, entry.name);
    entry.isDirectory() ? await copyDir(srcPath, destPath) : await import_promises.default.copyFile(srcPath, destPath);
  }
}

// src/manifests.ts
var import_path2 = __toESM(require("path"));

// src/assert.ts
var import_libassert = require("@brillout/libassert");
var libName = "vite-plugin-vercel";
function assert(condition, errorMessage) {
  if (condition) {
    return;
  }
  const err = (0, import_libassert.newError)(`[${libName}][Wrong Usage] ${errorMessage}`, 2);
  throw err;
}

// src/schemas/manifests/routes.ts
var import_zod = require("zod");
var routesManifestRedirectSchema = import_zod.z.object({
  source: import_zod.z.string(),
  destination: import_zod.z.string(),
  statusCode: import_zod.z.number().refine((n) => [301, 302, 307, 308].includes(n)),
  regex: import_zod.z.string()
}).strict();
var routesManifestHeaderSchema = import_zod.z.object({
  source: import_zod.z.string(),
  headers: import_zod.z.array(import_zod.z.object({
    key: import_zod.z.string(),
    value: import_zod.z.string()
  }).strict()),
  regex: import_zod.z.string()
}).strict();
var routesManifestRewriteSchema = import_zod.z.object({
  source: import_zod.z.string(),
  has: import_zod.z.array(import_zod.z.object({
    key: import_zod.z.string(),
    value: import_zod.z.string(),
    type: import_zod.z.enum(["header", "cookie", "host", "query"])
  }).strict()).optional(),
  destination: import_zod.z.string(),
  regex: import_zod.z.string()
}).strict();
var routesManifestDynamicRouteSchema = import_zod.z.object({
  page: import_zod.z.string(),
  regex: import_zod.z.string(),
  routeKeys: import_zod.z.record(import_zod.z.string()).optional(),
  namedRegex: import_zod.z.string().optional()
}).strict();
var routesManifestSchema = import_zod.z.object({
  version: import_zod.z.literal(3),
  basePath: import_zod.z.string().regex(/^\/.*/),
  pages404: import_zod.z.boolean(),
  redirects: import_zod.z.array(routesManifestRedirectSchema).optional(),
  headers: import_zod.z.array(routesManifestHeaderSchema).optional(),
  rewrites: import_zod.z.array(routesManifestRewriteSchema).optional(),
  dynamicRoutes: import_zod.z.array(routesManifestDynamicRouteSchema).optional()
}).strict();

// src/schemas/manifests/functions.ts
var import_zod2 = require("zod");
var functionsManifestSchemaPage = import_zod2.z.object({
  runtime: import_zod2.z.string().optional(),
  handler: import_zod2.z.string().optional(),
  regions: import_zod2.z.array(import_zod2.z.string()).optional(),
  maxDuration: import_zod2.z.number().min(1).max(900).optional(),
  memory: import_zod2.z.number().min(128).max(3008).optional()
}).strict();
var functionsManifestSchemaPageWeb = functionsManifestSchemaPage.omit({
  runtime: true
}).merge(import_zod2.z.object({
  runtime: import_zod2.z.literal("web"),
  env: import_zod2.z.array(import_zod2.z.string()),
  files: import_zod2.z.array(import_zod2.z.string()),
  name: import_zod2.z.string(),
  page: import_zod2.z.string(),
  regexp: import_zod2.z.string(),
  sortingIndex: import_zod2.z.number()
}).strict());
var functionsManifestSchema = import_zod2.z.object({
  version: import_zod2.z.literal(1),
  pages: import_zod2.z.object({
    "_middleware.js": functionsManifestSchemaPageWeb.optional()
  }).and(import_zod2.z.record(import_zod2.z.intersection(functionsManifestSchemaPageWeb.omit({
    runtime: true
  }).partial(), functionsManifestSchemaPage)))
});

// src/schemas/manifests/prerender.ts
var import_zod3 = require("zod");
var prerenderManifestSchemaRoute = import_zod3.z.object({
  initialRevalidateSeconds: import_zod3.z.number(),
  srcRoute: import_zod3.z.string(),
  dataRoute: import_zod3.z.string()
}).strict();
var prerenderManifestSchemaDynamicRoute = import_zod3.z.object({
  routeRegex: import_zod3.z.string(),
  fallback: import_zod3.z.string().or(import_zod3.z.null()),
  dataRoute: import_zod3.z.string(),
  dataRouteRegex: import_zod3.z.string()
}).strict();
var prerenderManifestSchema = import_zod3.z.object({
  version: import_zod3.z.literal(3),
  routes: import_zod3.z.record(prerenderManifestSchemaRoute),
  dynamicRoutes: import_zod3.z.record(prerenderManifestSchemaDynamicRoute),
  preview: import_zod3.z.object({
    previewModeId: import_zod3.z.string().or(import_zod3.z.null())
  }).strict()
}).strict();

// src/manifests.ts
function getPrerenderManifest(resolvedConfig, isrPages) {
  var _a, _b;
  const prerenderManifestDefault = (_a = resolvedConfig.vercel) == null ? void 0 : _a.prerenderManifest;
  const routes = Object.entries((isrPages == null ? void 0 : isrPages.routes) ?? {}).reduce((acc, [key, val]) => {
    var _a2, _b2, _c, _d, _e, _f, _g;
    const srcRoute = (val == null ? void 0 : val.srcRoute) ?? ((_b2 = (_a2 = prerenderManifestDefault == null ? void 0 : prerenderManifestDefault.routes) == null ? void 0 : _a2[key]) == null ? void 0 : _b2.srcRoute);
    assert(typeof srcRoute === "string", `\`[prerender-manifest] { srcRoute }\` is required for route ${key}`);
    acc[key === "/" ? "/index" : key] = {
      initialRevalidateSeconds: (val == null ? void 0 : val.initialRevalidateSeconds) ?? ((_d = (_c = prerenderManifestDefault == null ? void 0 : prerenderManifestDefault.routes) == null ? void 0 : _c[key]) == null ? void 0 : _d.initialRevalidateSeconds) ?? ((_e = resolvedConfig.vercel) == null ? void 0 : _e.initialRevalidateSeconds) ?? 86400,
      srcRoute,
      dataRoute: (val == null ? void 0 : val.dataRoute) ?? ((_g = (_f = prerenderManifestDefault == null ? void 0 : prerenderManifestDefault.routes) == null ? void 0 : _f[key]) == null ? void 0 : _g.dataRoute) ?? ""
    };
    return acc;
  }, {});
  const dynamicRoutes = Object.entries((isrPages == null ? void 0 : isrPages.dynamicRoutes) ?? {}).reduce((acc, [key, val]) => {
    var _a2;
    const override = (_a2 = prerenderManifestDefault == null ? void 0 : prerenderManifestDefault.dynamicRoutes) == null ? void 0 : _a2[key];
    const routeRegex = (val == null ? void 0 : val.routeRegex) ?? (override == null ? void 0 : override.routeRegex);
    const fallback = (val == null ? void 0 : val.fallback) === null || typeof (val == null ? void 0 : val.fallback) === "string" ? val == null ? void 0 : val.fallback : (override == null ? void 0 : override.fallback) === null || typeof (override == null ? void 0 : override.fallback) === "string" ? override == null ? void 0 : override.fallback : null;
    assert(routeRegex, `\`[prerender-manifest] { routeRegex }\` is required for route ${key}`);
    acc[key] = {
      routeRegex,
      fallback,
      dataRoute: (val == null ? void 0 : val.dataRoute) ?? (override == null ? void 0 : override.dataRoute) ?? "",
      dataRouteRegex: (val == null ? void 0 : val.dataRouteRegex) ?? (override == null ? void 0 : override.dataRouteRegex) ?? ""
    };
    return acc;
  }, {});
  return prerenderManifestSchema.parse({
    version: 3,
    routes,
    dynamicRoutes,
    preview: {
      previewModeId: ((_b = prerenderManifestDefault == null ? void 0 : prerenderManifestDefault.preview) == null ? void 0 : _b.previewModeId) ?? null
    }
  });
}
function getPrerenderManifestDestination(resolvedConfig) {
  return import_path2.default.join(getOutput(resolvedConfig), "prerender-manifest.json");
}
function getRoutesManifest(resolvedConfig, ssr) {
  var _a;
  const routesManifest = (_a = resolvedConfig.vercel) == null ? void 0 : _a.routesManifest;
  const allRewrites = [
    ...(routesManifest == null ? void 0 : routesManifest.rewrites) ?? [],
    ...(ssr == null ? void 0 : ssr.rewrites) ?? []
  ];
  const allDynamicRoutes = [
    ...(routesManifest == null ? void 0 : routesManifest.dynamicRoutes) ?? [],
    ...(ssr == null ? void 0 : ssr.dynamicRoutes) ?? []
  ];
  const allHeaders = [
    ...(routesManifest == null ? void 0 : routesManifest.headers) ?? [],
    ...(ssr == null ? void 0 : ssr.headers) ?? []
  ];
  return routesManifestSchema.parse({
    version: 3,
    basePath: (routesManifest == null ? void 0 : routesManifest.basePath) ?? "/",
    pages404: (routesManifest == null ? void 0 : routesManifest.pages404) ?? true,
    dynamicRoutes: allDynamicRoutes.length > 0 ? allDynamicRoutes : void 0,
    rewrites: allRewrites.length > 0 ? allRewrites : void 0,
    redirects: routesManifest == null ? void 0 : routesManifest.redirects,
    headers: allHeaders.length > 0 ? allHeaders : void 0
  });
}
function getRoutesManifestDestination(resolvedConfig) {
  return import_path2.default.join(getOutput(resolvedConfig), "routes-manifest.json");
}
function getFunctionsManifest(pages) {
  return functionsManifestSchema.parse({
    version: 1,
    pages
  });
}
function getFunctionsManifestDestination(resolvedConfig) {
  return import_path2.default.join(getOutput(resolvedConfig), "functions-manifest.json");
}

// src/build.ts
var import_fast_glob = __toESM(require("fast-glob"));
var import_path3 = __toESM(require("path"));
var import_esbuild = require("esbuild");
var import_promises2 = __toESM(require("fs/promises"));
function getPagesEndpoints(resolvedConfig) {
  var _a;
  const apiEndpoints = (((_a = resolvedConfig.vercel) == null ? void 0 : _a.pagesEndpoints) ?? []).map((p) => import_path3.default.isAbsolute(p) ? p : import_path3.default.resolve(getRoot(resolvedConfig), p));
  return new Set(apiEndpoints);
}
function getApiEntries(resolvedConfig) {
  var _a;
  const pagesEndpoints = getPagesEndpoints(resolvedConfig);
  const apiEntries = import_fast_glob.default.sync(`${getRoot(resolvedConfig)}/api/**/*.*([a-zA-Z0-9])`).filter((filepath) => !import_path3.default.basename(filepath).startsWith("_"));
  return apiEntries.reduce((entryPoints, filePath) => {
    const outFilePath = pathRelativeToApi(filePath, resolvedConfig);
    const parsed = import_path3.default.parse(outFilePath);
    const alsoPage = pagesEndpoints.has(filePath);
    const entry = {
      source: filePath,
      destination: [`api/${import_path3.default.join(parsed.dir, parsed.name)}`]
    };
    if (alsoPage) {
      entry.destination.push(`${import_path3.default.join(parsed.dir, parsed.name)}`);
    }
    entryPoints.push(entry);
    return entryPoints;
  }, ((_a = resolvedConfig.vercel) == null ? void 0 : _a.additionalEndpoints) ?? []);
}
var standardBuildOptions = {
  bundle: true,
  target: "es2020",
  format: "cjs",
  platform: "node",
  logLevel: "info",
  minify: true
};
async function buildFn(resolvedConfig, entry, buildOptions) {
  var _a, _b, _c, _d;
  if (!Array.isArray(entry.destination)) {
    entry.destination = [entry.destination];
  }
  assert(entry.destination.length > 0, `Endpoint ${typeof entry.source === "string" ? entry.source : "-"} does not have build destination`);
  const [firstDestination, ...remainingDestinations] = entry.destination;
  const pages = ((_b = (_a = resolvedConfig.vercel) == null ? void 0 : _a.functionsManifest) == null ? void 0 : _b.pages) ?? {};
  const fnManifests = {};
  const outfile = import_path3.default.join(getOutput(resolvedConfig, "server/pages"), firstDestination + ".js");
  const options = Object.assign({}, standardBuildOptions, { outfile });
  if (buildOptions) {
    Object.assign(options, buildOptions);
  }
  if (!options.stdin) {
    if (typeof entry.source === "string") {
      options.entryPoints = [entry.source];
    } else {
      assert(typeof entry.source === "object", `\`{ source }\` must be a string or an object`);
      assert(typeof entry.source.contents === "string", `\`{ contents }\` must be a string`);
      options.stdin = entry.source;
    }
  }
  await (0, import_esbuild.build)(options);
  fnManifests[firstDestination + ".js"] = __spreadValues({
    maxDuration: (_c = resolvedConfig.vercel) == null ? void 0 : _c.defaultMaxDuration
  }, pages[firstDestination + ".js"]);
  for (const dest of remainingDestinations) {
    await import_promises2.default.mkdir(import_path3.default.join(getOutput(resolvedConfig, "server/pages"), import_path3.default.dirname(dest)), {
      recursive: true
    });
    await import_promises2.default.copyFile(outfile, import_path3.default.join(getOutput(resolvedConfig, "server/pages"), dest + ".js"));
    fnManifests[dest + ".js"] = __spreadValues({
      maxDuration: (_d = resolvedConfig.vercel) == null ? void 0 : _d.defaultMaxDuration
    }, pages[dest + ".js"] ?? pages[firstDestination + ".js"]);
  }
  return fnManifests;
}
async function buildApiEndpoints(resolvedConfig) {
  const entries = getApiEntries(resolvedConfig);
  const fnManifests = {};
  for (const entry of entries) {
    Object.assign(fnManifests, await buildFn(resolvedConfig, entry));
  }
  return fnManifests;
}

// src/prerender.ts
function execPrerender(resolvedConfig) {
  var _a;
  const prerender = (_a = resolvedConfig.vercel) == null ? void 0 : _a.prerender;
  if (prerender === false) {
    return;
  }
  return prerender == null ? void 0 : prerender(resolvedConfig);
}

// src/index.ts
function vercelPlugin() {
  let resolvedConfig;
  return {
    apply: "build",
    name: "vite-plugin-vercel",
    enforce: "post",
    configResolved(config) {
      resolvedConfig = config;
    },
    async buildStart() {
      if (process.env.VERCEL_ENV === "production" && !process.env.ENABLE_FILE_SYSTEM_API) {
        throw new Error("Missing ENABLE_FILE_SYSTEM_API=1 to your environment variables in your project settings");
      }
      if (!resolvedConfig.build.ssr) {
        await cleanOutputDirectory(resolvedConfig);
      } else {
        await copyDistClientToOutputStatic(resolvedConfig);
      }
    },
    async writeBundle() {
      var _a;
      if (!((_a = resolvedConfig.build) == null ? void 0 : _a.ssr))
        return;
      const isrPages = await execPrerender(resolvedConfig);
      const fnManifests = await buildApiEndpoints(resolvedConfig);
      await generateFunctionsManifest(resolvedConfig, fnManifests);
      await generateRoutesManifest(resolvedConfig, isrPages == null ? void 0 : isrPages.ssr);
      await generatePrerenderManifest(resolvedConfig, isrPages == null ? void 0 : isrPages.isr);
    }
  };
}
async function copyDistClientToOutputStatic(resolvedConfig) {
  await copyDir(getOutDir(resolvedConfig, "client"), getOutput(resolvedConfig, "static"));
}
async function cleanOutputDirectory(resolvedConfig) {
  await import_promises3.default.rm(getOutput(resolvedConfig), {
    recursive: true,
    force: true
  });
}
async function generatePrerenderManifest(resolvedConfig, isrPages) {
  await import_promises3.default.writeFile(getPrerenderManifestDestination(resolvedConfig), JSON.stringify(getPrerenderManifest(resolvedConfig, isrPages), void 0, 2));
}
async function generateRoutesManifest(resolvedConfig, ssr) {
  await import_promises3.default.writeFile(getRoutesManifestDestination(resolvedConfig), JSON.stringify(getRoutesManifest(resolvedConfig, ssr), void 0, 2));
}
async function generateFunctionsManifest(resolvedConfig, fnManifests) {
  await import_promises3.default.writeFile(getFunctionsManifestDestination(resolvedConfig), JSON.stringify(getFunctionsManifest(fnManifests), void 0, 2));
}
function allPlugins() {
  return [vercelPlugin()];
}
module.exports = __toCommonJS(src_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
